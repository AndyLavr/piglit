# Verify that a indirect SSBO store always invalidates
# all previous load/store

[require]
GL >= 3.3
ES >= 3.1
GLSL >= 3.30
GL_ARB_compute_shader
GL_ARB_shader_atomic_counters

[compute shader]
#version 330
#extension GL_ARB_compute_shader: enable
#extension GL_ARB_shader_atomic_counters: enable
#extension GL_ARB_shader_storage_buffer_object: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform atomic_uint counter;
layout(std430) buffer SSBO {
  uint[3] vals;
} ssbo;
uniform uint ref_val;
uniform uint offset;

void main()
{
  uint tmp = ssbo.vals[1] + ref_val;
  ssbo.vals[offset] = ref_val * 2u;
  uint tmp1 = ssbo.vals[1];

  if (tmp == ref_val && tmp1 == ref_val * 2u)
    atomicCounterIncrement(counter);

  tmp = ssbo.vals[2] + ref_val;
  atomicAdd(ssbo.vals[offset + 1u], ref_val * 2u);
  tmp1 = ssbo.vals[2];

  if (tmp == ref_val && tmp1 == ref_val * 2u)
    atomicCounterIncrement(counter);

}

[test]
atomic counters 1
ssbo 12

uniform uint ref_val 5
uniform uint offset 1u

compute 1 1 1
probe atomic counter 0 == 2
