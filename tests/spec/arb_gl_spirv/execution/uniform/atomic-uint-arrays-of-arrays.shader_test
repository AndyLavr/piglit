# Tests arrays of atomic counters in a fragment shader.

[require]
SPIRV YES
GL >= 3.3
GLSL >= 3.30
ARB_gl_spirv

[vertex shader passthrough]

[fragment shader spirv]
; Automatically generated from the GLSL by shader_test_spirv.py. DO NOT EDIT
; SPIR-V
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 6
; Bound: 76
; Schema: 0
               OpCapability Shader
               OpCapability AtomicStorage
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %color
               OpExecutionMode %main OriginLowerLeft
               OpSource GLSL 450
               OpName %main "main"
               OpName %a0 "a0"
               OpName %a "a"
               OpName %a0_expected "a0_expected"
               OpName %color "color"
               OpName %a1 "a1"
               OpName %a1_expected "a1_expected"
               OpName %a2 "a2"
               OpName %a2_expected "a2_expected"
               OpDecorate %a Offset 4
               OpDecorate %a DescriptorSet 0
               OpDecorate %a Binding 0
               OpDecorate %a0_expected Location 0
               OpDecorate %a0_expected DescriptorSet 0
               OpDecorate %color Location 0
               OpDecorate %a1_expected Location 1
               OpDecorate %a1_expected DescriptorSet 0
               OpDecorate %a2_expected Location 2
               OpDecorate %a2_expected DescriptorSet 0
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
       %uint = OpTypeInt 32 0
%_ptr_Function_uint = OpTypePointer Function %uint
     %uint_3 = OpConstant %uint 3
%_arr_uint_uint_3 = OpTypeArray %uint %uint_3
     %uint_2 = OpConstant %uint 2
%_arr__arr_uint_uint_3_uint_2 = OpTypeArray %_arr_uint_uint_3 %uint_2
%_ptr_AtomicCounter__arr__arr_uint_uint_3_uint_2 = OpTypePointer AtomicCounter %_arr__arr_uint_uint_3_uint_2
          %a = OpVariable %_ptr_AtomicCounter__arr__arr_uint_uint_3_uint_2 AtomicCounter
        %int = OpTypeInt 32 1
      %int_0 = OpConstant %int 0
%_ptr_AtomicCounter_uint = OpTypePointer AtomicCounter %uint
     %uint_1 = OpConstant %uint 1
     %uint_0 = OpConstant %uint 0
%_ptr_UniformConstant_uint = OpTypePointer UniformConstant %uint
%a0_expected = OpVariable %_ptr_UniformConstant_uint UniformConstant
       %bool = OpTypeBool
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
%_ptr_Output_v4float = OpTypePointer Output %v4float
      %color = OpVariable %_ptr_Output_v4float Output
    %float_1 = OpConstant %float 1
    %float_0 = OpConstant %float 0
  %float_255 = OpConstant %float 255
      %int_1 = OpConstant %int 1
%a1_expected = OpVariable %_ptr_UniformConstant_uint UniformConstant
  %float_0_1 = OpConstant %float 0.1
      %int_2 = OpConstant %int 2
%a2_expected = OpVariable %_ptr_UniformConstant_uint UniformConstant
  %float_0_2 = OpConstant %float 0.2
         %75 = OpConstantComposite %v4float %float_0 %float_1 %float_0 %float_1
       %main = OpFunction %void None %3
          %5 = OpLabel
         %a0 = OpVariable %_ptr_Function_uint Function
         %a1 = OpVariable %_ptr_Function_uint Function
         %a2 = OpVariable %_ptr_Function_uint Function
         %18 = OpAccessChain %_ptr_AtomicCounter_uint %a %int_0 %int_0
         %21 = OpAtomicLoad %uint %18 %uint_1 %uint_0
               OpStore %a0 %21
         %22 = OpLoad %uint %a0
         %25 = OpLoad %uint %a0_expected
         %27 = OpINotEqual %bool %22 %25
               OpSelectionMerge %29 None
               OpBranchConditional %27 %28 %29
         %28 = OpLabel
         %36 = OpLoad %uint %a0
         %37 = OpConvertUToF %float %36
         %39 = OpFDiv %float %37 %float_255
         %40 = OpCompositeConstruct %v4float %float_1 %float_0 %39 %float_1
               OpStore %color %40
               OpReturn
         %29 = OpLabel
         %44 = OpAccessChain %_ptr_AtomicCounter_uint %a %int_1 %int_1
         %45 = OpAtomicIIncrement %uint %44 %uint_1 %uint_0
               OpStore %a1 %45
         %46 = OpLoad %uint %a1
         %48 = OpLoad %uint %a1_expected
         %49 = OpINotEqual %bool %46 %48
               OpSelectionMerge %51 None
               OpBranchConditional %49 %50 %51
         %50 = OpLabel
         %53 = OpLoad %uint %a1
         %54 = OpConvertUToF %float %53
         %55 = OpFDiv %float %54 %float_255
         %56 = OpCompositeConstruct %v4float %float_1 %float_0_1 %55 %float_1
               OpStore %color %56
               OpReturn
         %51 = OpLabel
         %60 = OpAccessChain %_ptr_AtomicCounter_uint %a %int_1 %int_2
         %61 = OpAtomicIDecrement %uint %60 %uint_1 %uint_0
         %62 = OpISub %uint %61 %int_1
               OpStore %a2 %62
         %63 = OpLoad %uint %a2
         %65 = OpLoad %uint %a2_expected
         %66 = OpINotEqual %bool %63 %65
               OpSelectionMerge %68 None
               OpBranchConditional %66 %67 %68
         %67 = OpLabel
         %70 = OpLoad %uint %a2
         %71 = OpConvertUToF %float %70
         %72 = OpFDiv %float %71 %float_255
         %73 = OpCompositeConstruct %v4float %float_1 %float_0_2 %72 %float_1
               OpStore %color %73
               OpReturn
         %68 = OpLabel
               OpStore %color %75
               OpReturn
               OpFunctionEnd

[fragment shader]
#version 450

layout (location = 0) uniform uint a0_expected;
layout (location = 1) uniform uint a1_expected;
layout (location = 2) uniform uint a2_expected;

layout (binding = 0, offset = 4) uniform atomic_uint a[2][3];

out vec4 color;

void main()
{
	uint a0 = atomicCounter(a[0][0]);
	if (a0 != a0_expected) {
		color = vec4(1.0, 0.0, float(a0) / 255.0, 1.0);
		return;
	}

	uint a1 = atomicCounterIncrement(a[1][1]);
	if (a1 != a1_expected) {
		color = vec4(1.0, 0.1, float(a1) / 255.0, 1.0);
		return;
	}

	uint a2 = atomicCounterDecrement(a[1][2]);
	if (a2 != a2_expected) {
		color = vec4(1.0, 0.2, float(a2) / 255.0, 1.0);
		return;
	}

	color = vec4(0.0, 1.0, 0.0, 1.0);
}

[test]

atomic counter buffer 0 7

clear color 0.0 0.0 0.0 0.0
clear

atomic counter 0 0 0
atomic counter 0 1 3
atomic counter 0 2 6
atomic counter 0 3 9
atomic counter 0 4 12
atomic counter 0 5 15
atomic counter 0 6 18

uniform uint 0 3
uniform uint 1 15
uniform uint 2 17

# a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2]
#    3       6       9       12      15      18

probe atomic counter buffer 0 0 == 0
probe atomic counter buffer 0 4 == 3
probe atomic counter buffer 0 8 == 6
probe atomic counter buffer 0 12 == 9
probe atomic counter buffer 0 16 == 12
probe atomic counter buffer 0 20 == 15
probe atomic counter buffer 0 24 == 18

draw rect ortho 0 0 1 1

# a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2]
#    3       6       9       12      16      17

probe atomic counter buffer 0 0 == 0
probe atomic counter buffer 0 4 == 3
probe atomic counter buffer 0 8 == 6
probe atomic counter buffer 0 12 == 9
probe atomic counter buffer 0 16 == 12
probe atomic counter buffer 0 20 == 16
probe atomic counter buffer 0 24 == 17

probe rgba 0 0 0.0 1.0 0.0 1.0
