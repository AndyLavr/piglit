# Tests the program interface queries related with names over aggregate
# types (arrays, structs, arrays of arrays) in shaders constructed from
# SPIR-V binaries where no name reflection information is available.
#
# All the interfaces are tested but TRANSFORM_FEEDBACK_VARYING because, at the
# time of writing the test, the shader_runner does not support transform
# feedback.
#
# ATOMIC_COUNTER_BUFFER interface is also excluded, since active atomic
# counter buffer resources are not assigned name strings
# (ARB_program_interface_query) so that interface is not an allowed argument in
# such queries.
#
# ARB_gl_spirv:
#
# 22. How do the program interface query APIs work when no name reflection
#     information is available?
#
#    RESOLVED: The following naturally follows from the specification:
#
#    GetProgramInterfaceiv(.., pname=MAX_NAME_LENGTH, ..) -> params = 1
#    GetProgramResourceIndex(.., name) -> INVALID_INDEX
#    GetProgramResourceName(.., length, name) -> length=0, name = ""
#    GetProgramResourceiv(.., props=NAME_LENGTH, ..) -> params = 1
#    GetProgramResourceLocation(.., name) -> -1
#    GetProgramResourceLocationIndex(.., name) -> -1
#    ...

[require]
SPIRV ONLY
GL >= 3.3
GLSL >= 3.30
GL_ARB_gl_spirv

[vertex shader passthrough]

[fragment shader spirv]
; Automatically generated from the GLSL by shader_test_spirv.py. DO NOT EDIT
; SPIR-V
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 7
; Bound: 45
; Schema: 0
               OpCapability Shader
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %outColor
               OpExecutionMode %main OriginLowerLeft
               OpSource GLSL 450
               OpDecorate %outColor Location 0
               OpDecorate %u Location 1
               OpDecorate %u DescriptorSet 0
               OpDecorate %u Binding 1
               OpDecorate %_arr_v4float_uint_2 ArrayStride 16
               OpDecorate %_arr__arr_v4float_uint_2_uint_3 ArrayStride 32
               OpDecorate %_arr__arr__arr_v4float_uint_2_uint_3_uint_2 ArrayStride 96
               OpDecorate %_arr_v4float_uint_2_0 ArrayStride 16
               OpDecorate %_arr__arr_v4float_uint_2_0_uint_2 ArrayStride 32
               OpMemberDecorate %ComponentsBlock 0 Offset 0
               OpMemberDecorate %ComponentsBlock 1 Offset 192
               OpDecorate %ComponentsBlock Block
               OpDecorate %components DescriptorSet 0
               OpDecorate %components Binding 5
               OpMemberDecorate %parts_0 0 Offset 0
               OpMemberDecorate %parts_0 1 Offset 16
               OpMemberDecorate %SSBOComponentsBlock 0 Offset 0
               OpDecorate %SSBOComponentsBlock BufferBlock
               OpDecorate %ssbo_components DescriptorSet 0
               OpDecorate %ssbo_components Binding 0
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
%_ptr_Output_v4float = OpTypePointer Output %v4float
   %outColor = OpVariable %_ptr_Output_v4float Output
      %parts = OpTypeStruct %v4float %v4float
%_ptr_UniformConstant_parts = OpTypePointer UniformConstant %parts
          %u = OpVariable %_ptr_UniformConstant_parts UniformConstant
        %int = OpTypeInt 32 1
      %int_0 = OpConstant %int 0
%_ptr_UniformConstant_v4float = OpTypePointer UniformConstant %v4float
       %uint = OpTypeInt 32 0
     %uint_2 = OpConstant %uint 2
%_arr_v4float_uint_2 = OpTypeArray %v4float %uint_2
     %uint_3 = OpConstant %uint 3
%_arr__arr_v4float_uint_2_uint_3 = OpTypeArray %_arr_v4float_uint_2 %uint_3
%_arr__arr__arr_v4float_uint_2_uint_3_uint_2 = OpTypeArray %_arr__arr_v4float_uint_2_uint_3 %uint_2
%_arr_v4float_uint_2_0 = OpTypeArray %v4float %uint_2
%_arr__arr_v4float_uint_2_0_uint_2 = OpTypeArray %_arr_v4float_uint_2_0 %uint_2
%ComponentsBlock = OpTypeStruct %_arr__arr__arr_v4float_uint_2_uint_3_uint_2 %_arr__arr_v4float_uint_2_0_uint_2
%_arr_ComponentsBlock_uint_2 = OpTypeArray %ComponentsBlock %uint_2
%_ptr_Uniform__arr_ComponentsBlock_uint_2 = OpTypePointer Uniform %_arr_ComponentsBlock_uint_2
 %components = OpVariable %_ptr_Uniform__arr_ComponentsBlock_uint_2 Uniform
      %int_1 = OpConstant %int 1
%_ptr_Uniform_v4float = OpTypePointer Uniform %v4float
    %parts_0 = OpTypeStruct %v4float %v4float
%SSBOComponentsBlock = OpTypeStruct %parts_0
%_ptr_Uniform_SSBOComponentsBlock = OpTypePointer Uniform %SSBOComponentsBlock
%ssbo_components = OpVariable %_ptr_Uniform_SSBOComponentsBlock Uniform
       %main = OpFunction %void None %3
          %5 = OpLabel
         %16 = OpAccessChain %_ptr_UniformConstant_v4float %u %int_0
         %17 = OpLoad %v4float %16
         %32 = OpAccessChain %_ptr_Uniform_v4float %components %int_0 %int_0 %int_1 %int_1 %int_1
         %33 = OpLoad %v4float %32
         %34 = OpFAdd %v4float %17 %33
         %35 = OpAccessChain %_ptr_Uniform_v4float %components %int_0 %int_1 %int_1 %int_1
         %36 = OpLoad %v4float %35
         %37 = OpFAdd %v4float %34 %36
         %42 = OpAccessChain %_ptr_Uniform_v4float %ssbo_components %int_0 %int_1
         %43 = OpLoad %v4float %42
         %44 = OpFAdd %v4float %37 %43
               OpStore %outColor %44
               OpReturn
               OpFunctionEnd

[fragment shader]
#version 450

struct parts {
        vec4 u1;
        vec4 u2;
};

layout (location = 1) uniform parts u;

layout (location = 0) out vec4 outColor;

layout (binding = 5, std140) uniform ComponentsBlock
 {
    vec4 c1[2][3][2];
    vec4 c2[2][2];
 } components[2];

layout (binding = 0) buffer SSBOComponentsBlock
 {
    parts s1;
 } ssbo_components;

void main()
{
    outColor = u.u1 +
               components[0].c1[1][1][1] +
               components[0].c2[1][1] +
	       ssbo_components.s1.u2;
}

[test]
clear color 1.0 0.0 0.0 0.0
clear

# Initialization --

# ComponentsBlock
block binding 5
block array index 0
block offset 272
block offset 144
block offset 144
block offset 144
block offset 144
block offset 144
uniform vec4 ComponentsBlock.c1[1][1][1] 0.1 0.2 0.3 0.4
block offset 432
block offset 240
block offset 240
block offset 240
block offset 240
block offset 240
uniform vec4 ComponentsBlock.c2[1][1] 0.1 0.2 0.0 0.0

# u
uniform vec4 1 0.0 0.1 0.3 0.0
uniform vec4 2 0.0 0.0 0.0 0.0

# SSBOComponentsBlock
block binding 0
ssbo 0 32
# u2
ssbo 0 subdata float 16 0.0
ssbo 0 subdata float 20 0.0
ssbo 0 subdata float 24 0.1
ssbo 0 subdata float 28 0.0

# Queries --

# Inputs/outputs

verify program_interface_query interface GL_PROGRAM_INPUT GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_PROGRAM_INPUT 0 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_PROGRAM_INPUT 0 0 ""
verify program_interface_query resourceIndex GL_PROGRAM_INPUT "" GL_INVALID_INDEX
verify program_interface_query resourceLocation GL_PROGRAM_INPUT "" -1

verify program_interface_query interface GL_PROGRAM_OUTPUT GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_PROGRAM_OUTPUT 0 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_PROGRAM_OUTPUT 0 0 ""
verify program_interface_query resourceIndex GL_PROGRAM_OUTPUT "" GL_INVALID_INDEX
verify program_interface_query resourceLocation GL_PROGRAM_OUTPUT "" -1
verify program_interface_query resourceLocationIndex GL_PROGRAM_OUTPUT "" -1

# Uniforms

verify program_interface_query interface GL_UNIFORM GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 0 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 1 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 2 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 3 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 4 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 5 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 6 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 7 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 8 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM 9 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_UNIFORM 0 0 ""
verify program_interface_query resourceName GL_UNIFORM 1 0 ""
verify program_interface_query resourceName GL_UNIFORM 2 0 ""
verify program_interface_query resourceName GL_UNIFORM 3 0 ""
verify program_interface_query resourceName GL_UNIFORM 4 0 ""
verify program_interface_query resourceName GL_UNIFORM 5 0 ""
verify program_interface_query resourceName GL_UNIFORM 6 0 ""
verify program_interface_query resourceName GL_UNIFORM 7 0 ""
verify program_interface_query resourceName GL_UNIFORM 8 0 ""
verify program_interface_query resourceName GL_UNIFORM 9 0 ""
verify program_interface_query resourceIndex GL_UNIFORM "" GL_INVALID_INDEX
verify program_interface_query resourceLocation GL_UNIFORM "" -1

# Uniform blocks

verify program_interface_query interface GL_UNIFORM_BLOCK GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM_BLOCK 0 GL_NAME_LENGTH 1
verify program_interface_query resource GL_UNIFORM_BLOCK 1 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_UNIFORM_BLOCK 0 0 ""
verify program_interface_query resourceName GL_UNIFORM_BLOCK 1 0 ""
verify program_interface_query resourceIndex GL_UNIFORM_BLOCK "" GL_INVALID_INDEX

# SSBOs

verify program_interface_query interface GL_SHADER_STORAGE_BLOCK GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_SHADER_STORAGE_BLOCK 0 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_SHADER_STORAGE_BLOCK 0 0 ""
verify program_interface_query resourceIndex GL_SHADER_STORAGE_BLOCK "" GL_INVALID_INDEX

# Buffer variables

verify program_interface_query interface GL_BUFFER_VARIABLE GL_MAX_NAME_LENGTH 1
verify program_interface_query resource GL_BUFFER_VARIABLE 0 GL_NAME_LENGTH 1
verify program_interface_query resource GL_BUFFER_VARIABLE 1 GL_NAME_LENGTH 1
verify program_interface_query resourceName GL_BUFFER_VARIABLE 0 0 ""
verify program_interface_query resourceIndex GL_BUFFER_VARIABLE "" GL_INVALID_INDEX

# Subroutines
#
# ARB_gl_spirv
#
# 25. What about subroutine queries based on names?

#    RESOLVED. SPIR-V does not currently support subroutines, so it is not
#    possibly to have any active subroutines from a SPIR-V based shader,
#    and thus there is never anything to report.

verify program_interface_query interface GL_VERTEX_SUBROUTINE GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_FRAGMENT_SUBROUTINE GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_GEOMETRY_SUBROUTINE GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_COMPUTE_SUBROUTINE GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_TESS_CONTROL_SUBROUTINE GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_TESS_EVALUATION_SUBROUTINE GL_MAX_NAME_LENGTH 0

verify program_interface_query interface GL_VERTEX_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_FRAGMENT_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_GEOMETRY_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_COMPUTE_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_TESS_CONTROL_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0
verify program_interface_query interface GL_TESS_EVALUATION_SUBROUTINE_UNIFORM GL_MAX_NAME_LENGTH 0

draw rect -1 -1 2 2
probe all rgba 0.2 0.5 0.7 0.4
